library(methods)
 
########################################################################################
# Set of functions for returning functional group names (character vector)
# using the type input column
#
# Internal supporting function for group names to check type 
#'
#' @importFrom methods is
#'
grouptype <- function(Rpath) {
  if (is(Rpath,"Rpath")) {
    gt<-list(type=Rpath$type, grp=Rpath$Group)
  } else {
    if (is(Rpath,"Rpath.params")) {
      gt<-list(type=Rpath$model$Type, grp=Rpath$model$Group)}
    else{
      stop("Input must be an Rpath (balanced) or Rpath.params (unbalanced) object.")
    }
  }
  names(gt$type)<-NULL; names(gt$grp)<-NULL
  return(gt)
}
####################################
#' Rpath functional group names
#' 
#' Get a character vector of functional group names from an Rpath object (balanced model)  
#' or an Rpath.params object (unbalanced model parameters) based on the 'type' input
#' parameter as follows: (0: consumers, 1: producers, 2: detrital, 3: gears, 0<type<1: mixotrophs).
#' Living groups are consumers + producers.  Note that mixotrophs are not returned as
#' either consumers or producers, only separately.  
#' 
#'@name rpath.groups
#' 
#'@family Rpath functions
#'
#'@param Rpath Balanced Rpath model generated by rpath.
#'
#'@return Returns a character vector containing the names of Rpath functional groups
#'by category (group type).
#'
#'@export
rpath.groups <- function(Rpath){
  gt <- grouptype(Rpath)
  return(gt$grp)
}

#'@rdname rpath.groups
#'@export
rpath.living <- function(Rpath){
  gt <- grouptype(Rpath)
  return(gt$grp[gt$type<2])
}

#'@rdname rpath.groups
#'@export 
rpath.detrital <- function(Rpath){
  gt <- grouptype(Rpath)
  return(gt$grp[gt$type==2])
}

#'@rdname rpath.groups
#'@export 
rpath.gears     <- function(Rpath){
  gt <- grouptype(Rpath)
  return(gt$grp[gt$type==3])
}

#'@rdname rpath.groups
#'@export 
rpath.producers <- function(Rpath){
  gt <- grouptype(Rpath)
  return(gt$grp[gt$type==1])
}

#'@rdname rpath.groups
#'@export 
rpath.consumers <- function(Rpath){
  gt <- grouptype(Rpath)
  return(gt$grp[gt$type==0])
}

#'@rdname rpath.groups
#'@export 
rpath.mixotrophs <- function(Rpath){
  gt <- grouptype(Rpath)
  return(gt$grp[gt$type>0 & gt$type<0])
}

#################################################################################
#' Extract start and end states from an rsim run output.
#' 
#' Extract the starting or ending biomass or catch from the output of an rsim run.
#'
#'@name RsimEndpoints
#'
#'@family Rpath functions
#'
#'@param Rsim.output An Rsim output object generated by rsim.run or rsim.step.
#'
#'@return Returns a named vector of starting or ending biomass or catch.
NULL

#'@rdname RsimEndpoints 
#'@export 
starting.biomass <- function(Rsim.output){
  return(Rsim.output$out_Biomass[1, 2:(dim(Rsim.output$out_Biomass)[2])])
}

#'@rdname RsimEndpoints 
#'@export 
ending.biomass <- function(Rsim.output){
  return(Rsim.output$out_Biomass[dim(Rsim.output$out_Biomass)[1], 2:(dim(Rsim.output$out_Biomass)[2])])
}

#'@rdname RsimEndpoints 
#'@export 
starting.catch <- function(Rsim.output){
  return(Rsim.output$out_Catch[1, 2:(dim(Rsim.output$out_Catch)[2])])
}

#'@rdname RsimEndpoints 
#'@export 
ending.catch <- function(Rsim.output){
  return(Rsim.output$out_CC[dim(Rsim.output$out_Catch)[1], 2:(dim(Rsim.output$out_Catch)[2])])
}



###############################################################################

#'@export
rsim.deriv.q <- function(Rpath.scenario, year=0, month=0, tstep=0){
  scene <- copy(Rpath.scenario)
  rout <- deriv_vector(scene$params,  scene$start_state, 
                       scene$forcing, scene$fishing,
                       scene$stanzas, year, month, tstep)
  
  rtab <- data.frame(scene$params$spname[scene$params$PreyTo+1], 
                     scene$params$spname[scene$params$PreyFrom+1],
                     rout$Qlink)
  colnames(rtab)<-c("Predator","Prey","Q")
  return(rtab)
}

###############################################################################
#'@export
get.rsim.predprey <- function(scene,predator="all",prey="all"){  
  pd <- scene$params$spname[scene$params$PreyTo+1]
  py <- scene$params$spname[scene$params$PreyFrom+1]
  if (predator=="all") predator <- scene$params$spname
  if (prey=="all")     prey     <- scene$params$spname
  link <- which((pd %in% predator) & (py %in% prey))
  predname <- pd[link]
  preyname <- py[link]
  QQ <- scene$params$QQ[link]
  DD <- scene$params$DD[link]
  VV <- scene$params$VV[link]
  PredPredWeight <- scene$params$PredPredWeight[link]
  PreyPreyWeight <- scene$params$PreyPreyWeight[link]
  HandleSwitch <- scene$params$HandleSwitch[link]
  return(data.frame(link,predname,preyname,QQ,VV,DD,
                    HandleSwitch,PredPredWeight,PreyPreyWeight))
}  

###############################################################################
#'@export
get.rsim.predprey.link <- function(scene,predator="all",prey="all"){  
  pd <- scene$params$spname[scene$params$PreyTo+1]
  py <- scene$params$spname[scene$params$PreyFrom+1]
  if (predator=="all") predator <- scene$params$spname
  if (prey=="all")     prey     <- scene$params$spname
  link <- which((pd %in% predator) & (py %in% prey))
  return(link)
}  

###############################################################################
#'@export
adjust.rsim.predprey <- function(scene,parameter,
                                 predator="all",prey="all",values){  
  pd <- scene$params$spname[scene$params$PreyTo+1]
  py <- scene$params$spname[scene$params$PreyFrom+1]
  if (predator=="all") predator <- scene$params$spname
  if (prey=="all")     prey     <- scene$params$spname
  link <- which((pd %in% predator) & (py %in% prey))
  
  if (parameter %in% c('QQ', 'VV', 'DD', 'HandleSwitch', 'PredPredWeight', 
                       'PreyPreyWeight')){
    scene$params[[parameter]][link] <- values
  }
  else {(warning(parameter," is not a valid predator/prey parameter."))}
  
  return(scene)
}   

###############################################################################



